#!/bin/sh
set -eu

# -----------------------------------------------------------------------------
# hummingbot_seed.sh
#
# One-shot bootstrap script (runs in the emqx:5 image) that creates the full
# folder/file layout required by your Hummingbot Trading Pod stack on FIRST RUN.
#
# Design goals:
#   - Idempotent: safe to run repeatedly.
#   - Non-destructive: will NOT overwrite existing non-empty files.
#   - TrueNAS-friendly: creates all bind-mount targets used by your compose.
#   - Fixes a common Docker bind-mount pitfall where a missing host *file* path
#     becomes a *directory* (we rename it aside and create the file).
#
# Fixes applied (2026-02-25):
#   - Creates conf_client.yml with mexc paper_trade support and SAL balance.
#   - Copies conf_client.yml into API bots/credentials/master_account/ so
#     the Dashboard Deploy V2 endpoint can find it when creating instances.
#   - Note: .password_verification is generated by a separate init container
#     (hummingbot-password-init) using the hummingbot image, since the emqx
#     image does not have the required Python crypto libraries.
# -----------------------------------------------------------------------------

umask 022

# Optional: strip CR/SOH and surrounding single quotes from injected env values
sanitize() {
  # usage: sanitize "value"
  printf %s "${1:-}" | tr -d '\r\001' | sed "s/^'//;s/'\$//"
}

ADMIN_USER_ID="$(sanitize "${ADMIN_USER_ID:-}")"
TELEGRAM_TOKEN="$(sanitize "${TELEGRAM_TOKEN:-}")"

BASE="/humming_dir"

# ---------- helpers ----------
now_ts() {
  date +%s 2>/dev/null || echo 0
}

ensure_dir() {
  # usage: ensure_dir /path/to/dir
  mkdir -p "$1"
}

ensure_file_from_stdin() {
  # usage:
  #   ensure_file_from_stdin /path/to/file <<'TAG'
  #   content...
  #   TAG
  file="$1"

 # If Docker created a directory where we expect a file, move it out of the way.
  if [ -d "$file" ]; then
    ts="$(now_ts)"
    mv "$file" "${file}.bak_dir_${ts}" 2>/dev/null || true
  fi

  ensure_dir "$(dirname "$file")"

  # Only write defaults when the file is missing OR empty
  if [ ! -s "$file" ]; then
    cat > "$file"
  fi
}

is_dir_empty() {
  # usage: is_dir_empty /path/to/dir  (returns 0 if empty)
  dir="$1"
  [ -d "$dir" ] || return 0

  # If ls fails (permissions), treat as non-empty to avoid accidental overwrite
  if ls -A "$dir" >/dev/null 2>&1; then
    [ -z "$(ls -A "$dir" 2>/dev/null || true)" ]
  else
    return 1
  fi
}

# ---------- paths (match the compose bind mounts) ----------
GLUETUN_DIR="$BASE/gluetun"

HBOT_BASE="$BASE/hummingbot"
HBOT_CONF="$HBOT_BASE/conf"
HBOT_LOGS="$HBOT_BASE/logs"
HBOT_DATA="$HBOT_BASE/data"
HBOT_CERTS="$HBOT_BASE/certs"
HBOT_SCRIPTS="$HBOT_BASE/scripts"
HBOT_CONTROLLERS="$HBOT_BASE/controllers"

GATEWAY_BASE="$BASE/gateway"
GATEWAY_CONF="$GATEWAY_BASE/conf"
GATEWAY_LOGS="$GATEWAY_BASE/logs"
GATEWAY_CERTS="$GATEWAY_BASE/certs"

POSTGRES_DATA="$BASE/postgres/data"

EMQX_BASE="$BASE/emqx"
EMQX_DATA="$EMQX_BASE/data"
EMQX_LOG="$EMQX_BASE/log"
EMQX_ETC="$EMQX_BASE/etc"

API_BOTS="$BASE/api/data/bots"
API_CONNECTORS="$API_BOTS/credentials/master_account/connectors"
API_MASTER="$API_BOTS/credentials/master_account"

MCP_DIR="$BASE/controllers/mcp"

DASHBOARD_CRED="$BASE/dashboard/credentials.yml"

CONDOR_BASE="$BASE/condor"
CONDOR_DATA="$CONDOR_BASE/data"
CONDOR_ROUTINES="$CONDOR_BASE/routines"
CONDOR_CONFIG="$CONDOR_BASE/config.yml"

BOOTSTRAP_DIR="$BASE/bootstrap"

# ---------- start ----------

echo "=== mount check ==="
if [ ! -d "$BASE" ]; then
  echo "ERROR: $BASE is not a directory (bind mount missing?)."
  exit 1
fi
ls -la "$BASE" || true

echo "=== creating directory tree ==="
ensure_dir "$BOOTSTRAP_DIR"
ensure_dir "$GLUETUN_DIR"

ensure_dir "$HBOT_CONF"
ensure_dir "$HBOT_LOGS"
ensure_dir "$HBOT_DATA"
ensure_dir "$HBOT_CERTS"
ensure_dir "$HBOT_SCRIPTS"
ensure_dir "$HBOT_CONTROLLERS"

ensure_dir "$GATEWAY_CONF"
ensure_dir "$GATEWAY_LOGS"
ensure_dir "$GATEWAY_CERTS"

ensure_dir "$POSTGRES_DATA"

ensure_dir "$EMQX_DATA"
ensure_dir "$EMQX_LOG"
ensure_dir "$EMQX_ETC"

ensure_dir "$API_BOTS"
ensure_dir "$API_CONNECTORS"
ensure_dir "$API_MASTER"

ensure_dir "$MCP_DIR"

ensure_dir "$(dirname "$DASHBOARD_CRED")"

ensure_dir "$CONDOR_DATA"
ensure_dir "$CONDOR_ROUTINES"
ensure_dir "$(dirname "$CONDOR_CONFIG")"

# ---------- files ----------

echo "=== creating dashboard creds (if missing/empty) ==="
ensure_file_from_stdin "$DASHBOARD_CRED" <<'__DASH_CREDS__'
username: admin
password: admin
__DASH_CREDS__

# ---------- conf_client.yml ----------
# This file is needed by:
#   1. The hummingbot client container (at /home/hummingbot/conf/conf_client.yml)
#   2. The hummingbot-api Deploy V2 endpoint (at bots/credentials/master_account/conf_client.yml)
# We create it once in the hummingbot conf dir then copy to the API master_account.

echo "=== creating conf_client.yml (if missing/empty) ==="
ensure_file_from_stdin "$HBOT_CONF/conf_client.yml" <<'__CONF_CLIENT__'
####################################
###   client_config_map config   ###
####################################

instance_id: null

# Fetch trading pairs from all exchanges if True, otherwise fetch only from connected exchanges.
fetch_pairs_from_all_exchanges: false

log_level: INFO

debug_console: false

strategy_report_interval: 900.0

logger_override_whitelist:
- hummingbot.strategy.arbitrage
- hummingbot.strategy.cross_exchange_market_making
- conf

log_file_path: /home/hummingbot/logs

kill_switch_mode: {}

# What to auto-fill in the prompt after each import command (start/config)
autofill_import: disabled

# MQTT Bridge configuration.
mqtt_bridge:
  mqtt_host: 127.0.0.1
  mqtt_port: 1883
  mqtt_username: ''
  mqtt_password: ''
  mqtt_namespace: hbot
  mqtt_ssl: false
  mqtt_logger: true
  mqtt_notifier: true
  mqtt_commands: true
  mqtt_events: true
  mqtt_external_events: true
  mqtt_autostart: true

# Error log sharing
send_error_logs: true

db_mode:
  db_engine: sqlite

balance_asset_limit: {}

# Fixed gas price (in Gwei) for Ethereum transactions
manual_gas_price: 50.0

# Gateway API Configurations
gateway:
  gateway_api_host: 127.0.0.1
  gateway_api_port: '15888'
  gateway_use_ssl: false

# Whether to enable aggregated order and trade data collection
anonymized_metrics_mode:
  anonymized_metrics_interval_min: 15.0

rate_oracle_source:
  name: binance

# A universal token which to display tokens values in, e.g. USD,EUR,BTC
global_token:
  global_token_name: USDT
  global_token_symbol: $

rate_limits_share_pct: 100.0

commands_timeout:
  create_command_timeout: 10.0
  other_commands_timeout: 30.0

# Tabulate table format style
tables_format: psql

paper_trade:
  paper_trade_exchanges:
  - binance
  - kucoin
  - kraken
  - gate_io
  - mexc
  paper_trade_account_balance:
    BTC: 1.0
    USDT: 100000.0
    USDC: 100000.0
    ETH: 20.0
    WETH: 20.0
    SOL: 100.0
    DOGE: 1000000.0
    HBOT: 10000000.0
    SAL: 10000.0

color:
  top_pane: '#000000'
  bottom_pane: '#000000'
  output_pane: '#262626'
  input_pane: '#1C1C1C'
  logs_pane: '#121212'
  terminal_primary: '#5FFFD7'
  primary_label: '#5FFFD7'
  secondary_label: '#FFFFFF'
  success_label: '#5FFFD7'
  warning_label: '#FFFF00'
  info_label: '#5FD7FF'
  error_label: '#FF0000'
  gold_label: '#FFD700'
  silver_label: '#C0C0C0'
  bronze_label: '#CD7F32'

tick_size: 1.0

market_data_collection:
  market_data_collection_enabled: false
  market_data_collection_interval: 60
  market_data_collection_depth: 20
__CONF_CLIENT__

# Copy conf_client.yml to the API master_account directory.
# This is where the Deploy V2 endpoint looks when creating bot instances.
echo "=== copying conf_client.yml to API master_account ==="
if [ -f "$HBOT_CONF/conf_client.yml" ]; then
  cp -n "$HBOT_CONF/conf_client.yml" "$API_MASTER/conf_client.yml" 2>/dev/null || true
fi

echo "=== creating condor config (if missing/empty) ==="
ADMIN_ID_LINE="admin_id: null"
case "$ADMIN_USER_ID" in
  "")
    ADMIN_ID_LINE="admin_id: null"
    ;;
  *[!0-9]*)
    # Keep YAML valid even if someone passes a non-numeric id
    ADMIN_ID_LINE="admin_id: \"$ADMIN_USER_ID\""
    ;;
  *)
    ADMIN_ID_LINE="admin_id: $ADMIN_USER_ID"
    ;;
esac

# Expand variables for token/admin_id line
ensure_file_from_stdin "$CONDOR_CONFIG" <<__CONDOR_CFG__
token: "$TELEGRAM_TOKEN"
$ADMIN_ID_LINE
servers: {}
default_server: null
users: {}
server_access: {}
chat_defaults: {}
audit_log: []
__CONDOR_CFG__

# ---------- EMQX seed ----------

echo "=== seeding emqx etc (copy defaults if missing) ==="
# Copy default /opt/emqx/etc into bind mount without overwriting user changes.
# If you already edited files in $EMQX_ETC, they will be preserved.
if is_dir_empty "$EMQX_ETC" || [ ! -f "$EMQX_ETC/emqx.conf" ]; then
  # Prefer -n (no clobber) if available
  cp -a -n /opt/emqx/etc/. "$EMQX_ETC/" 2>/dev/null || cp -a /opt/emqx/etc/. "$EMQX_ETC/" 2>/dev/null || true
fi

# ---------- permissions ----------

echo "=== permissions ==="
# Broadly permissive to avoid "permission denied" on TrueNAS datasets.
# Postgres is tightened afterwards to avoid initdb permission errors.
chmod -R 777 "$BASE" 2>/dev/null || true

# Tighten Postgres data dir (it can refuse to init if group/world accessible).
# Official postgres image uses uid/gid 999 on many systems.
chown -R 999:999 "$POSTGRES_DATA" 2>/dev/null || true
chmod 700 "$POSTGRES_DATA" 2>/dev/null || true

# Prefer EMQX ownership if user exists in this image
EMQX_UID="$(id -u emqx 2>/dev/null || true)"
EMQX_GID="$(id -g emqx 2>/dev/null || true)"
if [ -n "${EMQX_UID:-}" ] && [ -n "${EMQX_GID:-}" ]; then
  chown -R "$EMQX_UID:$EMQX_GID" "$EMQX_BASE" 2>/dev/null || true
fi

echo "Pre-flight check complete."